<!doctype html>
<html lang="en">
  	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
		<style>
			code{
				background-color: rgba(0,0,0,.075);
				font-weight: bold;
			}
			.subtitle{
				font-size: 1.3rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 5px;
				background-color: rgba(0,0,0,.075);
				text-align: center;
			}
			h3{
				font-size: 2rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 10px;
			}
			.paragraph{
				margin: 0.5rem 0 0.5rem;
			}
			.tab{
				margin: 0 1rem;
			}
			html{
				scroll-behavior: smooth;
			}
			</style>

		<title>Gatsby</title>
  	</head>
  	<body>
      
    <div class="container">
		<h1 class="display-3 text-center">Gatsby<hr></h1>
		<header>
			<p class="paragraph">
				Overall description.
			</p>
		</header>

		<h2 id="00" class="subtitle">Index</h2>
		<table class="table table-striped">
			<thead>
				<tr>
					<th scope="col">#</th>
					<th scope="col">Topic</th>
					<th scope="col">Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th scope="row">1</th>
					<td>
						<a href="#01">topicName</a>
					</td>
					<td>
						<code>Code or description</code>
					</td>
				</tr>
			</tbody>
		</table>

		<ul class="list-group">
			<li class="list-group-item">
				<a id="01" href="#00">Index</a>
				<h2 class="subtitle">Intro to Gatsby</h2>
				<p class="paragraph">
					There are a few libraries/starters that handle rendering different. What we've done with React until now has been using CRA, which uses Client Side Rendering. This means that we send a single bundle to the browser, this bundle is then processed by the browser which creates the page as it goes. It dumps the workload of creating the web page to the browser. The second main library is NextJS, which uses React as well, but handles the creation of the pages on the server, this is called server side rendering. This is what we did with EJS. The server creates the page depending on what the user needs, and then sends it to the browser as a html, css, js bundle. Gatsby is the old school way of the web. We write our app in React, then we use Gatsby to create every possible web page/path and put it on the server. When the user calls a page, it is then sent by the server to the browser without the need of any rendering, beacuse the pages are pre-rendered. 
				</p>
				<p class="paragraph">
					<strong>Gatsby Starter</strong>
					We start a gatsby project by running <code>npx gatsby new project-name</code>, it has a few starters that give us starting templates for different kinds of pages we might want to create. We start by creating a <code>gatsby-blog</code>. The installation is slow and weighs 277MB. Gatsby comes with a few files, we will focus on the onse in the root directory. Gatsby can be used for SSR, however we won't be doing this. We will write node code in our <strong>gatsby-node.js</strong> file. <strong>gatsby-config.js</strong> holds the configuration options for Gatsby. 
				</p>
				<p class="paragraph">
					<strong>Gatsby Config</strong>
					<br>
					We see <strong>siteMetadata</strong> which is data that we can pull into our components using graphQL, mainly title, description, and author. <strong>plugins</strong> are additional libraries in Gatsby that let us do plenty of things with different files. Here we would add any plugins we might want to add. There are many plugins for Gatsby that we can see in the DOCS. 
				</p>
				<p class="paragraph">
					<strong>package.json</strong>
					<br>
					We can see that Gatsby comes with a bunch of scripts. We want to use <code>yarn develop</code> which will execute gatsby develop. This will build out our Gatsby application and <em>give us two routes</em>. The first one is localhost 8000, the second one is localhost:800/___graphql, which is our GraphQL playground. If we go to 8000 we can see the page that comes built in with the Gatsby starter. 
				</p>
				<a id="02" href="#00">Index</a>
				<h2 class="subtitle">Gatsby Pages</h2>
				<p class="paragraph">
					We have a src/pages dir with a few js files. If we create a new file here, Gatsby will automatically try to load a new page for you, which it will build based on the title that you give your file. The <strong>index.js</strong> holds our landing 'astronaut' page. It imports React and has a React.FC. It also uses <code>import { Link } from "gatsby"</code> which is the Gatsby version of the React Router Link. We also import 3 components <strong>Layout, Image, SEO</strong>. Layout wraps around HTML elements or Components, provides styling, and provides some data. The Image Component allows us to do Lazy loading with Images and makes images more performant on the web. The SEO component is meant for SEO, you can provide props for title, description, lang, and meta. 
				</p>
				<p class="paragraph">
					We create a new <strong>page-3.tsx</strong> file, and if we navigate to /page-3 we see that it loads. We also get a 404.js page, which Gatsby will use automatically in production if the user navigates to a page that doesn't exist. It is opinionated in how to handle routing and 404s, which is great beacuse we just have to follow along. The structure of Gatsby app will vary from our CRA, because every page we create needs every component we are going to use displaying it. This is why all of our pages are wrapped in Layout, which is a Gatsby Component that comes with the header and footer. 
				</p>
				<p class="paragraph">
					In our Layout component we can see that we use GraphQL. Gatsby created its own GraphQL hook <code>useStaticQuery</code> that allows to extract the value of the query you are making and pluck out the data. In layout we are querting <code>site{ siteMetadata { title } }</code> which is taken from our <strong>gatsby-config.js</strong> file. This allows us to use title in our component and use it in the Header. If we change totle in our config file, we see that it changes in every page. If we need to have access to some data on any part of our app, we can easily add it to <strong>siteMetadata</strong> and access it using GraphQL. 
				</p>
				<a id="03" href="#00">Index</a>
				<h2 class="subtitle">Gatsby GraphQL + Markdown</h2>
				<p class="paragraph">
					Gatsby comes with GraphQL as the default query language, which we can access with ___graphql. It comes pre-set with some great features, such as being able to access any file in our project dir. This is done through the plugin: <em>gatsby-source-filesystem</em>. In t=our config file we can set options that allow us to get to different parts of the FS.  
				</p>
				<p class="paragraph">
					<strong>allFile Query</strong>
					<br>
					In our GraphQL playgroun we use the <code>allFile</code> query, and if we ctrl+enter, it autocompletes the query. We get edges, node, and id. Edges is the file path that we have set. We get an array of the images we have in the directory. Inside we have a node[] which is the representation of every image that we have here. In our node we have access to plenty of properties in our node, such as absolutePath, relativePath, and many that we can see in the playgorund. This same structure is how we are going to build out our blog. We can now see a representation of our files, however we cannot access the data yet, for that we need to config Gatsby. 
				</p>
				<p class="paragraph">
					<strong>Markdown and our Blog</strong>
					<br>
					Our blog will be a node in allFile, which we need to write using Markdown. We will create a folder that holds all of our blog Markdwon files. We create /src/markdown-pages/icecream.md. On the top of the file we have three dashes <code>---</code> which represents the <strong>frontmatter</strong> which represents the data that you can pull off of the md file. With this you can pull out a snippet of the data in the blog post instead of the whole post. It can hold any metadata. Yihua pulls in another .md file that has a <code>&lt;iframe&gt;</code> tag which holds a link to a YouTube video. This is what you get from YT as an embedd link. MD gets compiled to HTML. 
				</p>
				<p class="paragraph">
					<strong>Accessing our md files</strong>
					<br>
					In our Gatsby config file, we copy the block of code that has our FS plugin. Here we change the name and path for our new queue, setting name to markdowns, and using markdown-pages in our path. I copied Yihuas md files to my project. Once we do that, we need to restart our server. We must do this if we change any plugin in our config file. Once we do this, we re-send the queue in our playground and we can se that if we run our queue once more we have our markdown files here. 
				</p>
				<a id="04" href="#00">Index</a>
				<h2 class="subtitle">Pulling Data from Markdown Nodes</h2>
				<p class="paragraph">
					We need to add a new plugin called a <strong>transformer</strong> which will give us the data from our nodes. These are libs that we have to install in our project. We <code>yarn add gatsby-transformer-remark</code> which will give us access to a new plugin object which we can use in our config. We add it in our plugins[] as <code>`gatsby-transformer-remark`</code>. Since we added a plugin we must restart our server.
				</p>
				<p class="paragraph">
					<strong>allMarkdownRemark query</strong>
					<br>
					After resetting the server we see that we have access to a new <code>allMarkdownRemark</code> query in our graphql playground. When we run our query for the edges and node, we see that we have 2 files here. Here we can see we have access to our <code>frontmatter</code> which has the vars that we set between ---. We query for <code>frontmatter { date description title } html</code>. We can see that html has our MD converted to HTML. We also have access to <code>excerpt</code> which is a snippet of HTML that we can show in an index or preview. 
				</p>
				<p class="paragraph">
					<strong>Using in a page</strong>
					<br>
					We go to our <strong>index.js</strong> page. We import graphql inside gatsby. Here we <code>const export query = graphql` query { ... }`</code> where we paste the query we used in our playground. Gatsby by default knows that any query that we export with graphql is to be used in the Component that is the default export in our file. This means that we have access to it in our props. We destructure <code>({ data })</code> in our props. Then we remove everything in the component except Layout and SEO, and inside we create a Div with an H1. Then we add <code>totalCount</code> to our query to get the number of posts we have. We then create an H4 with <code>{data.allMarkdownRemark.totalCount}</code>. If we go back to our app now we see that our count is displayed. We restructure our Component to <code>console.log(data)</code> to see what we get from the query, which matches our format.
				</p>
				<p class="paragraph">
					Once we have this we start structuring what we want to display. We want to map over our posts, we do this with <code>{data.allMarkdownRemark.edges.map(({node}) => ( ... ))}</code> which will map over the nodes which are our posts. Inside we will render a div, which uses the <strong>key</strong>, mandatory in JSX as <code>key={node.id}</code>. Inside we have a span that has the title and date from our frontmatter <code>node.frontmatter.title</code> and date. Then we have a p tag with the ecxeprt <code>node.excerpt.</code> Now we can see that we have a preview for our posts in the main page of our App. Now we have access to the data from our markdown files and everything will update automatically. 
				</p>
				<a id="04" href="#00">Index</a>
				<h2 class="subtitle">Creating the Slug</h2>
				<p class="paragraph">
					We will need to highjack the <strong>build</strong> step in our gatsby blog, we will get the html from our nodes and build pages for each node in our blog. We do this in our <strong>gatsby-node.js</strong> file. Here we write node-esque code, more details in the <a href="https://www.gatsbyjs.org/docs/node-apis/">Gatsby Node API DOCS</a>. Inside we <code>exports.onCreateNode = ({ node }) => { console.log(node.internal.type) }</code>. When we restart our server, we see that we get logs in our console, where we can see two MarkdownRemark logs. 
				</p>
				<p class="paragraph">
					We erase the log, and we change it to <code>if(node.internal.type === `MarkdownRemark`){ ... }</code>, where we will create something called a <strong>slug</strong>. A slug, in gatsby, is the URL that the browser can access from our app to navigate to the page required. We need to dynamically create this slug and attach it to the node as a field so we can access it in the application. We also have access to the <code>actions</code> property in our onCreateNode() Fn from gatsby that has actions we get by default. 
				</p>
				<p class="paragraph">
					We <code>const { createNodeField } = actions</code> to extract this action. Then we will build our slug. We <code>const { createFilePath } = require(`gatsby-source-filesystem`)</code>. Then inside our if condition we <code>const slug = createFilePath({ node })</code> which points to the node that we want to convert into a file path. Gatsby takes the name of the file and transforms it into the route that will be used. Then we need the method to get the node, <code>({ node, actions, getNode })</code>, we then use it in createFilePath(). This allows you pull out the <em>node object representation</em> of a file or edge. The third arg in our object is the optional <code>basePath</code> which allows us to add a base path to the URL. We won't use this. 
				</p>
				<p class="paragraph">
					Then we <code>createNodeField({ ... })</code> where we pass <code>node, name: `slug`, value: slug,</code>, now when we create our nodes in the build process we will end up appending a property named slug with the value of our slug <code>node { ...node, name: slug }</code>. Now we restart our server to apply the changes. In our GraphQL playground we now see that our nodes have a <strong>fields</strong> prop, where we have access to slug. <strong>Node:</strong> any field we add with createNodeField() will be added to this fields property. We can see that the slug has the path based on the name <code>"slug": "/ice-cream/"</code>. Now that we set up our node, we need to set up the page. 
				</p>
				<a id="05" href="#00">Index</a>
				<h2 class="subtitle">Gatsby node createPages() Setup and Template</h2>
				<p class="paragraph">
					We will build out the final pages from our site using our node and markdown files, where we will use the slug as well. We will need a new method <code>exports.createPages = ({ graphql, actions }) => { ... }</code> which gives us access to graphql queries in our node file and actions that we can use. We then <code>const {createPage} = actions</code>. Underneath we <code>return graphql(``)</code>, which needs the () because we don't have ES6 support out of the box, but it is the same as what we use in the front end with ES6 <code>graphql``</code>. 
				</p>
				<p class="paragraph">
					We create our query in the GarphQL playground. We then paste it in our query <code>return graphql(` { allMarkdownRemark { edges { node { fields { slug } } } } } `)</code> which will give us the data we need to pass to createPage. Since this query is a promise we use <code>.then(result => { ... }</code> where we <code>result.data.allMarkdownRemark.edges.forEach(({ node }) => { ... })</code>, Here we loop over all the nodes and call <code>createPage({ path: node.fields.slug, component: null })</code> which will create a page for each of our posts using a Component we create. For this we create a src/templates/ directory which will hold the Component we will use in createPage().
				</p>
				<p class="paragraph">
					<strong>Template Component</strong>
					<br>
					We create a <strong>blog-post.js</strong> file in our templates for our posts. We import React graphql and Layout. We have this in our templates/ directory because the pages that are application files are in pages/ files that we use to generate pages in the build go in templates/. Here we will have access to MD data from a graphql query that we will build. We make <code>export const query = grapql` query($slug: String!) { ... }`</code> Which is our own query that always gets a string value that we will call $slug. Then we will use it to search <code>markdownRemark(fields: { slug: { eq: $slug } })</code> when the fields.slug is equal to our $slug value. 
				</p>
				<p class="paragraph">
					We test out the query in the GraphQL playground. Where we create the queue and then look for <code>{ id fields { slug } }</code> where we use /ice-cream/ and get the result for the markdown file we are looking for. In our template we will just extract <code>{ html frontmatter { title } }</code>. In our Component code we <code>const post = data.markdownRemark</code>. Then we will create our <code>return ( ... )</code> we wrap everything in a Layout Component, and inside we create a div. Then we set h1 to <code>{post.frontmatter.title}</code> and then we create a div where we will use the html we get from our MD.
				</p>
				<p class="paragraph">
					We will use the React property <code>dangerouslySetInnerHTML={ ... }</code>, this is the preferred Gatsby way of setting this value. It says dangerously set because in React we don't want to use this, because the HTML is dynamically generated. Since Gatsby creates static pages, there is no danger here at all. Inside we <code>{{ __html: post.html }}</code> which will set the html from our graphql query as the html inside the div. 
				</p>
				<p class="paragraph">
					<strong>Using our component in gatsby node</strong>
					<br>
					The component prop in our createPage() is expecting a path. We need the path property. We <code>const path = require('path')</code> which comes default in js. Then we <code>component: path.resolve(`./src/templates/blog-post.js`),</code> For us to pass the <strong>slug</strong> value to our front end query we need to pass it with <code>context: { slug: node.fields.slug }</code>. After we complete this we restart our server. Now if we navigate to <code>/ice-cream/</code> we see our blog page was created. When we go to /my-frist-ama/ we see that the youtube video is there <em>awesome</em>. We have our blog set up to dynamically generate our posts and update our index, hooray.
				</p>
				<a id="06" href="#00">Index</a>
				<h2 class="subtitle">Finishing our Blog</h2>
				<p class="paragraph">
					We need to start by sorting our posts in the index to display latest first. In our index.js file we use the graphql sort method in our query <code>allMarkdownRemark(sort: {fields: [frontmatter___date], order: DESC}) { ... }</code>. We can do this query in the playground. Basically <code>___</code> three underscores is equal to . in this syntax. Now we want to link to the blog posts from these previews. To do this we add <code>fields { slug }</code> to our query. 
				</p>
				<p class="paragraph">
					Yihua wants to style the blog using styled-components, which we can do using a plugin. We <code>yarn add gatsby-plugin-styled-components styled-components babel-plugin-styled-components</code> to use it in gatsby. In our config file we add <code>`gatsby-plugin-styled-components`,</code> In our index.js we <code>import styled from 'styled-components';</code>. 
				</p>
				<p class="paragraph">
					We will create these components in the same file. We <code>const BlogLink = styled(Link)` text-decoration: none;`</code> which will use the Link Component and remove the default style for links. We then wrap the span with the title and date in our BlogLink Component. Then we use the to prop to redirect to our slug which is the path <code>to={node.fields.slug}</code>. 
				</p>
				<p class="paragraph">
					<strong>SideTrack: robots.txt</strong>
					<br>
					I ran lighthouse out of curiosity and got an error regarding a <strong>robots.txt</strong> file. I read on it and it is a file that tells web crawlers where they can find info for SEOs. By default I had an invalid robots.txt file. This is important because the benefit of gatsby is SEOs. I proceeded to look at the docs and found <a href="https://www.gatsbyjs.org/packages/gatsby-plugin-robots-txt/">gatsby-plugin-robots-txt</a> which is a plugin that creates a robots.txt file for your Gatsby site. I installed it and it didn't work, I then ran <code>yarn build</code> and found that the error was in the Gatsby config file. The plugin looks for a <code>siteUrl: String</code> prop in <code>siteMetadata</code> which should hold the url to the webpage for the robots.txt file. Once I set it to localhost, build ran well and with yarn develop I got no error running lighthouse. 
				</p>
				<p class="paragraph">
					
				</p>
			</li>
		</ul>
	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
	</body>
</html>